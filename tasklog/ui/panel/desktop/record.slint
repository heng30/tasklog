import { ListView, DatePickerPopup } from "std-widgets.slint";

import { RecordState, SortRecord, RecordEntry } from "../../store.slint";
import { Theme, Icons, Store, Util, Logic } from "../def.slint";
import { Search, LineInput, Label, IconBtn, FlashProgress, ConfirmBtn, TextBtnWithoutIcon, GainFocus, HorizontalLedNumber, Divider, Tag, CircleProgress } from "../../base/widgets.slint";

component StatePopup inherits PopupWindow {
    private property <[string]> values: [Logic.tr("Giveup"), Logic.tr("Finished"), Logic.tr("Unfinished")];

    callback update-task-state(state: string);

    Rectangle {
        background: Theme.base-background;
        border-width: Theme.default-border-width;
        border-color: Theme.base-border-color;

        VerticalLayout {
            spacing: Theme.spacing * 2;
            padding: Theme.padding * 2;

            for value[index] in values: Rectangle {
                background: state-pop-ta.has-hover ? Theme.hover-background : Theme.base-background;
                border-radius: Theme.border-radius;

                state-pop-hbox := HorizontalLayout {
                    padding: Theme.padding * 2;
                    Label {
                        text: value;
                        font-size: Theme.title5-font-size;
                    }
                }

                state-pop-ta := TouchArea {
                    mouse-cursor: self.has-hover ? MouseCursor.pointer : MouseCursor.default;
                    clicked => {
                        root.update-task-state(value);
                    }
                }
            }
        }
    }
}

component TopBar inherits HorizontalLayout {
    alignment: LayoutAlignment.center;

    Rectangle {
        width: 80%;
        height: hbox.preferred-height;
        border-radius: self.height / 2;
        background: Theme.secondary-background;
        border-width: Theme.default-border-width;
        border-color: Theme.base-border-color;

        hbox := HorizontalLayout {
            spacing: Theme.spacing * 4;
            padding: Theme.padding * 2;
            padding-left: Theme.padding * 4;
            padding-right: Theme.padding * 4;

            search := Search {
                gain-focus-when-clicked: false;

                search(text) => {
                    Logic.search-record(text);
                }

                edited(text) => {
                    Logic.search-record(text);
                }
            }

            IconBtn {
                icon: Icons.add-light;
                hover-color: Store.setting-preference.is-dark ? Theme.secondary-background.darker(50%) : Theme.secondary-background.darker(5%);

                clicked => {
                    Logic.add-record();
                }
            }
        }
    }
}

component TaskCard inherits Rectangle {
    in-out property <RecordEntry> entry;

    private property <bool> has-hover: ta.has-hover || state-btn.has-hover || more-icon.has-hover;

    function remain-days(start-date: string, end-date: string) -> [int] {
        return [4, 5, 8];
    }

    function calc-progress(start-date: string, end-date: string) -> float {
        return 0.5;
    }

    function state-color(state: RecordState) -> color {
        if (state == RecordState.Unfinished) {
            return Theme.thirdly-brand-color;
        } else if (state == RecordState.Finished) {
            return Theme.success-color;
        } else if (state == RecordState.Giveup) {
            return Theme.danger-color;
        } else {
            return Theme.warning-color;
        }
    }

    function state-to-str(state: RecordState) -> string {
        if (state == RecordState.Unfinished) {
            return Logic.tr("Unfinished");
        } else if (state == RecordState.Finished) {
            return Logic.tr("Finished");
        } else if (state == RecordState.Giveup) {
            return Logic.tr("Giveup");
        } else {
            return Logic.tr("Timeout");
        }
    }

    function str-to-state(state: string) -> RecordState {
        if (state == Logic.tr("Unfinished")) {
            return RecordState.Unfinished;
        } else if (state == Logic.tr("Finished")) {
            return RecordState.Finished;
        } else if (state == Logic.tr("Giveup")) {
            return RecordState.Giveup;
        } else {
            return RecordState.Timeout;
        }
    }

    preferred-width: vbox.preferred-width;
    preferred-height: vbox.preferred-height;
    background: Theme.secondary-background;
    border-radius: Theme.border-radius * 2;
    border-color: root.has-hover ? Theme.thirdly-brand-color : Theme.base-border-color;
    border-width: Theme.default-border-width;
    drop-shadow-blur: Theme.padding * 2;
    drop-shadow-color: self.border-color;

    states [
        zoom-in when root.has-hover: {
            width: vbox.preferred-width + Theme.padding * 2;
            height: vbox.preferred-height + Theme.padding * 2;
            in {
                animate width, height { duration: Theme.default-animate-duration; }
            }
            out {
                animate width, height { duration: Theme.default-animate-duration; }
            }
        }
        zoom-out when !root.has-hover: {
            width: vbox.preferred-width;
            height: vbox.preferred-height;
        }
    ]

    ta := TouchArea { }

    progress-bar := CircleProgress {
        x: Theme.padding * 2;
        y: Theme.padding * 2;
        radius: Theme.icon-size * 0.8;
        ring-width: Theme.padding;
        font-size: Theme.default-font-size * 2 / 3;
        finished-text: "100%";
        finished-progress-color: led-number.colorize;
        progress: calc-progress(entry.start-date, entry.end-date);
        height: self.width;
    }

    more-icon := IconBtn {
        x: root.width - self.width - Theme.padding * 4;
        y: Theme.padding * 4;
        width: Theme.icon-size;
        height: self.width;
        icon: Icons.more-v;
        hover-color: Store.setting-preference.is-dark ? Theme.secondary-background.darker(50%) : Theme.secondary-background.darker(5%);

        clicked => {
           // TODO
        }
    }

    vbox := VerticalLayout {
        padding: Theme.padding * 4;
        alignment: LayoutAlignment.center;

        num-hbox := HorizontalLayout {
            width: Theme.icon-size * 12;
            alignment: LayoutAlignment.center;

            HorizontalLayout {
                alignment: LayoutAlignment.center;

                led-number := HorizontalLedNumber {
                    number-spacing: Theme.spacing * 2;
                    number-padding: Theme.padding * 4;
                    number-size: Theme.icon-size * 2;
                    colorize: state-color(entry.state);
                    numbers: remain-days(entry.start-date, entry.end-date);
                }
            }

            VerticalLayout {
                alignment: LayoutAlignment.end;
                padding-bottom: Theme.padding * 4;

                Label {
                    text: entry.start-date != entry.end-date ? Logic.tr("days") : Logic.tr("day");
                    color: Theme.placeholder-text-color;
                }
            }
        }

        Divider {
            height: Theme.default-border-width * 2;
        }

        HorizontalLayout {
            padding-top: Theme.padding * 2;

            title-lb := Label {
                vertical-alignment: TextVerticalAlignment.top;
                width: num-hbox.width;
                height: title-lb.font-size * 3;
                font-size: Theme.title3-font-size;
                font-weight: Theme.bold-font-weight;
                wrap: word-wrap;
                text: entry.title;
                overflow: elide;
            }
        }

        VerticalLayout {
            alignment: LayoutAlignment.start;

            HorizontalLayout {
                alignment: LayoutAlignment.start;
                padding-top: Theme.padding * 4;
                spacing: Theme.spacing * 4;

                for index in 3: Tag {
                    visible: !self.text.is-empty;
                    text: index == 0 && entry.tags.length >= 1 ? entry.tags[index] : (entry.tags.length >= 2 && index == 1 ? entry.tags[index] : (entry.tags.length >= 3 && index == 2 ? entry.tags[index] : ""));
                    background: Theme.tag-colors[index];
                    hpadding: Theme.padding * 2;
                    text-color: self.background.darker(150%);
                }
            }
        }

        HorizontalLayout {
            alignment: LayoutAlignment.space-between;
            padding-top: Theme.padding * 4;

            state-btn := TextBtnWithoutIcon {
                text: state-to-str(entry.state);
                text-color: led-number.colorize;
                font-weight: Theme.bold-font-weight;

                clicked => {
                    state-popup.show();
                }
            }

            Label {
                text: Logic.tr("Ends on ") + entry.end-date;
                color: Theme.placeholder-text-color;
            }
        }
    }

    state-popup := StatePopup {
        x: state-btn.absolute-position.x - root.absolute-position.x + state-btn.width / 2 - self.width / 2;
        y: state-btn.absolute-position.y - root.absolute-position.y - self.height - Theme.padding * 2;

        update-task-state(value) => {
            Logic.update-task-state(str-to-state(value));
        }
    }
}

export component Record inherits Rectangle {
    GainFocus { }

    VerticalLayout {
        private property <length> task-card-width: Theme.icon-size * 12;
        private property <int> column-counts: (self.width - Theme.padding * 8 - Theme.padding * 8 * 2) / task-card-width;
        private property <int> row-counts: Math.ceil(Store.record-entries.length / column-counts);

        spacing: Theme.spacing * 2;

        TopBar {
            width: 100%;
        }

        ListView {
            for row-index in row-counts: VerticalLayout {
                padding: Theme.padding * 4;

                HorizontalLayout {
                    spacing: Theme.spacing * 8;
                    alignment: LayoutAlignment.space-around;

                    for column-index in column-counts: Rectangle {
                        width: tc.width;
                        height: tc.height;

                        tc := TaskCard {
                            private property <int> current-index: row-index * column-counts + column-index;
                            private property <bool> is-show-card: current-index < Store.record-entries.length;

                            init => {
                                task-card-width = Math.max(self.preferred-width, task-card-width);
                            }

                            visible: is-show-card;
                            entry: Store.record-entries[ is-show-card ? current-index : 0];
                        }
                    }
                }
            }
        }
    }
}
